本包的经典问题是最早的经典LeetCode题目，也是做过的题目，重新梳理一遍

1. 难理解的题目：

2. 很有启发的题目：
   * 3. Longest Substring Without Repeating Characters
      > O(n)时间复杂度 Sliding Window
      > Sliding Window是一种常常用于array/string问题的抽象概念，i，j都是索引，[ i, j ) 左闭右开就是window，
      > sliding window就是左右两个边界向特定方向slide，比如向右slide 1，就是[ i + 1, j + 1 )。
      > 回到问题本身，我们用HashSet储存当前window [ i, j ) 的字符，最初时候 i = j ，
      > 然后我们向右slide j，如果slide后的字符不在HashSet中，就继续向右slide，
      > 直到S[j]已经存在于HashSet中为止。在这个点我们就找到了以索引 i 为起点的最大子字符串，
      > 我们对所有 i 操作一遍就可以得到结果了。
   * 7. Reverse Integer
	  > 1. 由于int数据类型是32位，范围是-2^32 到 2^32 - 1，后面有out = out * 10 + x % 10的操作，
	       out有可能overflow，所以用long类型声明out，因为long类型是64位，范围是-2^63 到 2^63 - 1
      > 2. 记住reverse int的算法：只要x != 0： out = out * 10 + x % 10; x = x / 10;
      > 3. 由于out类型一开始设置成了更大容器long,由于最后要转换成int,需要有out的overflow判断，
           out若大于Integer.MAX_VALUE(2^31 - 1)或者小于Integer.MIN_VALUE(-2^31)，返回0。
      > 4. 最后返回out要做强制类型转换成int：(int)out
   * 8. String to Integer (atoi)
      > 1. 用trim()方法移除空格字符
	  > 2. 移除空格后的字符再判断是否为null以及length()是否为0
      > 3. + - 判断
      > 4. 计算真实值
           1. 由于int数据类型是32位，范围是-2^32 到 2^32 - 1，后面有tmp = tmp * 10 + digit的操作，
              tmp有可能overflow，所以用long类型声明out，因为long类型是64位，范围是-2^63 到 2^63 - 1
           2. i < str.length()循环，int digit = str.charAt(i) - '0’;
              1. 正则tmp = 10*tmp + digit; 随时判断是否overflow
              2. 负则tmp = 10*tmp - digit; 随时判断是否overflow
      > 5. 返回 (int) tmp
    * 11. Container With Most Water
        > 1. 这题可以暴力破解双重循环，但是复杂度很高，我们这里用双pointer，初始时候分别指向最左和最右
		> 2. 用一个参数ans储存结果
		> 3. 将指向矮高度的指针向中间移动（由于面积等于矮的那个高度乘以(r - l)，所以如果矮的高度不变，缩进长的那个面积不可能变大）
		> 4. 返回ans
    * 29. Divide Two Integers
		> 1. 特殊条件判断（corner case）：
		    * divisor = 0 的时候
		    * dividend = 0 的时候
		    * dividend = Integer.MIN_VALUE && divisor = -1 的时候：之所以需要这个判断，是因为integer范围是[-2^31, 2^31 - 1], 所以这种情况会导致结果是 -Integer.MIN_VALUE(2^31), 这是大于Integer.MAX_VALUE (2^31 - 1) 的, 所以按照题目约定，overflow返回Integer.MAX_VALUE
		> 2. 正负号
		> 3. 用到移位运算符，x << n = x * 2^n
		> 4. 由于正负号前面确定了，且为了防止左移操作导致的overflow，将dividend和divisor变成long类型切取绝对值
		> 5. 举例子 32 / 3:
		    1. 3 << 1 = 6
		    2. 3 << 2 = 12
		    3. 3 << 3 = 24
		    4. 3 << 4 = 48 (48 > 32, 终止)
		    5. 32 - 24 = 8
		    6. 3 << 1 = 6
		    7. 3 << 2 = 12 (12 > 8, 终止）
		    8. 8 - 6 = 2 < 3, 不需要看了，终止循环，所以循环条件是a >= b，否则终止循环
		    9. 结果就是2^3 + 2^1 = 10
     * 31. Next Permutation
         > 举例：[1，5，8，4，7，6，5，3，1]）
		 > 1. 首先我们观察到descending order的序列是找不到next larger排列的，比如[5, 4, 3, 2, 1]
		 > 2. 我们从右往左，要找到第一对a[i]和a[i - 1], 要求a[i] > a[i - 1]， 即找到第一个升序的位置：i和i - 1，也就是a[i] = 7, a[i - 1] = 4
		 > 3. 从4(a[i - 1])的右侧找到next larger的数a[j]，也就是5， 然后交换（自定义函数swap：将nums数组中的i位置和j位置元素交换）它们: [1, 5, 8, 4, 7, 6, 5, 3, 1] -----> [1, 5, 8, 5, 7, 6, 4, 3, 1]
		 > 4. a[i - 1] 的右侧必然变成descending order，将它们reverse（自定义函数reverse：将nums数组中start位置及start位置以后的元素全部reverse）成ascending order后就得到了我们需要的答案：[1, 5, 8, 5, 1, 3, 4, 6, 7]
         
     

3. 经典题目：
   * 1. Two Sum
      > Map的key - value对是nums[i] & i
   * 15. 3Sum
      > 1. 对nums排序，用Arrays.sort(nums)
	  > 2. 既然是3-sum，需要用i，j，k三个指针
      > 3. i从0开始，j从1开始，k从最后一个开始，i从左往右一个个移动，j 和 k 始终在 i 右边，j 和 k 类似sliding window
   * 16. 3Sum Closest   
   * 18. 4Sum
	   > 1. 和3Sum去重操作是一样的，但是注意3Sum这道题默认的target是0，所以当nums[i]大于0的时候就直接break，但是这里是指定target，注意不可以nums[i] > 0 的时候直接break，因为如果target是负数，比如-11，nums[i] = -9, 后面有可能加的是-2。
	   > 2. 4Sum就是多引入了一个维度而已
   * 20. Valid Parentheses
	   > 1. 这里要用stack结构，因为括号是对称出现才valid
	   > 2. 注意pop()是把stack顶的对象移除并返回该对象，所以调用pop方法stack顶对象就被移除了
	   > 3. 注意最后返回是stack.isEmpty()，因为输入的String s如果是对称的，自然stack 最后会empty，反之比如说输入是“【”，则stack不empty，返回false
       
   


	 
