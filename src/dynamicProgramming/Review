1. 难理解的题目：

2. 很有启发的题目：
   * 53. Maximum Subarray:
     > current elemrnt:     [-2, 1, -3, 4, -1, 2, 1, -5, 4] (原始nums[i])
     > current max sum:     [-2, 1, -2, 4,  3, 5, 6,  1, 5]（if(nums[i-1]>0) nums[i]+=nums[i-1]之后的nums[i]）
     > max sum seen so far: [-2, 1,  1, 4,  4, 5, 6,  6, 6]（maxSum）
   * 5. Longest Palindromic Substring 也可以用DP来做，这道题在palindrome包中
     > dp[i][j]表示从i到j的字符串是否是回文串
     > 若s[i] == s[j]，是否回文取决于dp[i + 1][j - 1]
     > 若s[i] != s[j]，dp[i][j]直接就是false
     > dp的进行是按字符串长度从1～n推进的
   * 96. Unique Binary Search Trees 树的动归，在tree包中
   * 338. Counting Bits
     > 转移方程比较有启发性
     > 小tips: x / 2 is x >> 1 and x % 2 is x & 1
   * 139. Word Break
     > 用到了三种方法：暴力递归，备忘录递归（自顶向下dp），动态规划（自底向上）
   * 152. Maximum Product Subarray
   	 > 典型dp: 利用dp数组
   	 > 优化dp: 不用dp数组，深入理解dp核心本质，降低空间复杂度
   	        > 通过观察状态转移函数，我们可以看出，每次计算只是用到前一个maxhere和minhere，
   	          所以这里可以对程序进行改进，每次对前一个maxhere和minhere做记录，这样就节省了空间的存储。

3. 一些重点
   * 常见步骤：1. 构建dp数组 2. 初始化 3. 转移方程 参考典型题目：70. Climbing Stairs
   * 不是每一个dp问题都是一个数组，都是返回数组最后一位的，dp的思想只是记录之前的状态而减少暴力递归的复杂度，甚至不是每一个dp都需要数组
     > 152. Maximum Product Subarray

	  