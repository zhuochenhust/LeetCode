1. 难理解的题目：

2. 很有启发的题目：
	* 14. Longest Common Prefix
	  这题思路很直接，先从字符串数组中第一个字符串拿开头的子串作prefix，然后一个个地看数组后面的字符串是不是都是以这个prefix开头的。
	  关键问题在于，这个prefix的长度怎么选取。 我的第一种算法就是以prefix长度为1开始，到2到3...直到某一个长度的prefix不是共同prefix为止。
	  改进方法：以后看到这种长度选取的，一个个累加不如二分快，要有用二分法的敏感性。这就是改进方法. 
	* 151. 判断一个char是否为空格，两种方式，第一种：看是否等于32；第二种：Character.isSpace(s.charAt(i - 1))
	* 804. 一个字符c在26个字母中的位置，可以用c - 'a'来表示，这样比创建一个字符串s="abcdefghijklmnopqrstuvwxyz"然后用s.indexOf(c)来获得简单一些
	* 43. Multiply Strings
	* 709. To Lower Case
	  ascii table显示 小写的字符等于大写+32
	* 383. RansomNote
	  用char - ‘a’ 将a - z字符变成0-26，可以对应数组下标，数组下标对应的值就是对应字符出现的次数，很巧妙，字符的题目少不了和数字对应。
	  只要某个字符对应的数字为下标的位置数组值为0，则说明不存在所需要的字符，返回false
	 
