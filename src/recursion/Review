1. 难理解的题目：
   * 698. Partition to K Equal Sum Subsets
     > 比较典型的一道回溯法递归的题目，有一些难度，反复多揣摩, 416. Partition Equal Subset Sum和698解法思路是一模一样的几乎
   * 761. Special Binary String
     题目分析：
     > 这道题给了我们一个特殊的二进制字符串，说是需要满足两个要求，一是0和1的个数要相等，
       二是任何一个前缀中的1的个数都要大于等于0的个数。
     > 其实就是一个括号字符串啊。这里的'1'表示左括号，'0'表示右括号，那么题目中的两个限制条件其实就是限定这个括号字符串必须合法，即左右括号的个数必须相同，且左括号的个数随时都要大于等于右括号的个数。
     > 那么这道题让我们通过交换子字符串，生成字母顺序最大的特殊字符串，注意这里交换的子字符串也必须是特殊字符串，满足题目中给定的两个条件，换作括号来说就是交换的子括号字符串也必须是合法的。
     > 那么我们来想什么样的字符串是字母顺序最大的呢，根据题目中的例子可以分析得出，应该是1靠前的越多越好，那么换作括号来说就是括号嵌套多的应该放在前面。
     具体递归写法：
     > 由于我们移动的子字符串也必须是合法的，那么我们利用检测括号字符串合法性的一个最常用的方法，就是遇到左括号加1，遇到右括号-1，这样得到0的时候，就是一个合法的子字符串了。
     > 我们用变量anchor来表示这个合法子字符串的起始位置，list来保存这些合法的子字符串。
     > 好了，我们开始遍历字符串S，遇到1，cnt自增1，否则自减1。当cnt为0时，我们将这个字串加入list
     > 注意前面说过，我们需要给这个字串自身也排序，所以我们要对自身调用递归函数，我们不用对整个子串调用递归，因为字串的起始位置和结束位置是确定的，一定是1和0，我们只需对中间的调用递归即可
     > 然后更新anchor为i + 1。
     > 我们将所有的符合条件的字符对加入list，然后用Collections.sort(list, Collections.reverseOrder())将字母顺序大的放前面
     > 最后将排序后的list用sb拼接起来返回即可
   
      

2. 很有启发的题目：
   * 70. Climbing Stairs: 
     > 就两种跳法，要么眺一个台阶，要么眺两个台阶，如果跳一个台阶，剩下n-1个没有跳，剩下的跳法f(n-1);如果眺两个台阶，那么剩下n-2个没有跳,剩下的跳法f(n-2)。
     > 但是直接这么做，效率低下，因为很多递归的结果被重复计算了，我们可以把计算结果用array保存起来，把n作为数组的下标，f（n）作为数组的值，如果array[n]!=0,
     > 则说明已经被计算过了，直接返回；如果等于0，说明还没被计算过，那么让array[n]=f(n)=f(n-1)+f(n-2)再返回array[n]就可以了。
	
   * 894. All Possible Full Binary Trees
     > 1. 我们用了Map<Integer, List<TreeNode>> map，key为N，value为对应的list
     > 2. 左右必然都是FBT，左边左边节点数l从0～N-1，右边节点数r = N - 1 - l
     > 3. 递归过程中的l和r在0～N范围内, 而用map储存每一个n = 0～N对应的结果，可以大幅度节约时间，不然每个相同的0～N为input的结果都要再算一遍，
           那样将大幅增加运算时间。
           
3. Tips
   > 关于递归函数的参数，举个例子，如果用递归遍历二叉树时，可能需要记录每个节点的值或者经过的节点数目，前者可以用
     list来实现，由于list是引用对象，递归的每一次调用都会对其进行修改，只需要作为函数的参数传导，然后直接返回就
     可以了。
     但是如果要计算经过的节点数的时候，传的是一个基础类型int，是一个普通变量，如果不用临时变量，变量的值在完成该次
     函数调用之后的修改不会返回到上一层去，必须用一个临时变量把它记录下来并传入下一个函数中，这就是为什么RangeSumOfBST_938
     定义了一个临时变量ans，而不是把ans作为递归函数的参数。
   > 递归用StringBuilder和String的区别: 见 22. Generate Parentheses
