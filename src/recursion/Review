1. 难理解的题目：
   * 698. Partition to K Equal Sum Subsets
     > 比较典型的一道回溯法递归的题目，有一些难度，反复多揣摩, 416. Partition Equal Subset Sum和698解法思路是一模一样的几乎
   * 761. Special Binary String
     > 这道题目和括号本质一模一样，'1'代表正括号，'0'代表反括号，然后输出尽可能1在前面的字符串
     > 字符串的开头一定是'1'，结尾一定是'0'，中间则是合理的(类似正反括号规则)的'1''0'字符对
     > 我们将所有的符合条件的字符对加入list，然后用Collections.sort(list, Collections.reverseOrder());从大到小排序
     > 将排序后的list用sb拼接起来返回即可
   
      

2. 很有启发的题目：
   * 70. Climbing Stairs: 
     > 就两种跳法，要么眺一个台阶，要么眺两个台阶，如果跳一个台阶，剩下n-1个没有跳，剩下的跳法f(n-1);如果眺两个台阶，那么剩下n-2个没有跳,剩下的跳法f(n-2)。
     > 但是直接这么做，效率低下，因为很多递归的结果被重复计算了，我们可以把计算结果用array保存起来，把n作为数组的下标，f（n）作为数组的值，如果array[n]!=0,
     > 则说明已经被计算过了，直接返回；如果等于0，说明还没被计算过，那么让array[n]=f(n)=f(n-1)+f(n-2)再返回array[n]就可以了。
	
   * 894. All Possible Full Binary Trees
     > 1. 我们用了Map<Integer, List<TreeNode>> map，key为N，value为对应的list
     > 2. 左右必然都是FBT，左边左边节点数l从0～N-1，右边节点数r = N - 1 - l
     > 3. 递归过程中的l和r在0～N范围内, 而用map储存每一个n = 0～N对应的结果，可以大幅度节约时间，不然每个相同的0～N为input的结果都要再算一遍，
           那样将大幅增加运算时间。
           
3. Tips
   > 关于递归函数的参数，举个例子，如果用递归遍历二叉树时，可能需要记录每个节点的值或者经过的节点数目，前者可以用
     list来实现，由于list是引用对象，递归的每一次调用都会对其进行修改，只需要作为函数的参数传导，然后直接返回就
     可以了。
     但是如果要计算经过的节点数的时候，传的是一个基础类型int，是一个普通变量，如果不用临时变量，变量的值在完成该次
     函数调用之后的修改不会返回到上一层去，必须用一个临时变量把它记录下来并传入下一个函数中，这就是为什么RangeSumOfBST_938
     定义了一个临时变量ans，而不是把ans作为递归函数的参数。
   > 递归用StringBuilder和String的区别: 见 22. Generate Parentheses
