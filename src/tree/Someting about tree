关于Tree的一些思考：
1. 前中后序遍历的实际应用是什么？
	1.1 前序遍历：输出某个文件夹下所有文件名称(可以有子文件夹)—用前序遍历实现
	1.2 后序遍历：统计某个文件夹的大小（该文件夹下所有文件的大小）–用后序遍历实现
	1.3 中序遍历：假设一个表达式，a+b*c+d-e/f，利用将其存储在二叉树中，保持中序遍历得到中缀表达式，中缀表达式是一个通用的算术或逻辑公式表示方法。符合人类的逻辑（例：3 + 4） 
		后缀表达式是一种不需要括号的表达法。符合计算机的逻辑（例：3 4 +） 
2. 前序遍历其实就是DFS，那么顺便总结下DFS和BFS
	2.1 DFS:数据结构：栈, 父节点入栈，父节点出栈，先右子节点入栈，后左子节点入栈。遍历全部节点即可
	2.2 BFS:数据结构：队列, 父节点入队，父节点出队列，先左子节点入队，后右子节点入队。遍历全部节点即可，和102题一模一样。
	那我自己顺便简单实现一下DFS和BFS, 见BinaryTreeSearch.java
	
3. 解题思路：
	3.1 递归：Tree的题目是很容易用到递归的
	
	
4. 常见问题：
	4.1 求二叉树深度(最大深度：见Solution 110, 最小深度： 见Solution 111)
	4.2 DFS，BFS实现(见BinaryTreeSearch，用stack实现DFS，用queue实现BFS，见114，递归同样可以实现)
	
5. 难理解的题目：
	* 96. Unique Binary Search Trees: 一般只要你返回数量，不让你返回每种具体结构是什么，一般想想动态规划
	* 124. Binary Tree Maximum Path Sum
	* 297. Serialize and Deserialize Binary Tree

6. 很有启发的题目：
	* 110. Balanced Binary Tree， 
	  > 迭代法（Iteration），用循环：用BFS或者DFS遍历每一个节点，看每一个node是否左left的深度和right深度差距不大于1，
	    当然需要写一个递归方法findMaxDepth。
	  > 递归法（Recursion）：这是一种改进，同样也需要写一个求深度的递归方法findMaxDepth，但是非常巧妙地是，在求深度的同时，我们就判断他平不平衡，不平衡返回-1，平衡才正常返回，这是非常巧妙的。
	* 235. Lowest Common Ancestor of a Binary Search Tree
	  > 递归法空间复杂度O(log(N))~O(N)
	  > Iteration 空间复杂度O(1)
	* 105, 106, 654
	  > 每次递归用到数组的一部分，不要想着去每次用Arrays.copyOfRange创建新的数组，而是要在递归函数中加入左右边界参数，这样不会每次递归浪费额外空间创建新数组
	* 235, 236 类似，一个是求二分查找树的两个节点的最小祖先(递归或者循环)，一个是求普通二叉树的两个节点的最小祖先(分治算法)
	
7. 复杂度
	* 一般只要涉及到遍历整个树，不论是DFS还是BFS，时间复杂度都是O(N)
	* 一般数都涉及到遍历整个树，比如100题SameTree，用了递归，递归所需空间复杂度是递归最大深度*每次递归所需辅助空间个数，最差的情况Tree完全不平衡，空间复杂度就是O(N)，因为每一层一个node，最差情况N个node全部都要存在递归开辟的stack里，空间复杂度位O(N)，
	   但是如果是最好的情况，一个完全平衡的二叉树，复杂度就是O(log(N)